[
    {
        "method_name": "bellmanford",
        "method_code": "public class BELLMANFORD {\n    void BELLMANFORD(Graph graph, int src) \n    { \n        int V = graph.V, E = graph.E; \n        int dist[] = new int[V]; \n\n        for (int i = 0; i < V; ++i) \n            dist[i] = Integer.MAX_VALUE; \n        dist[src] = 0; \n \n        for (int i = 1; i < V; ++i) { \n            for (int j = 0; j < E; ++j) { \n                int u = graph.edge[j].src; \n                int v = graph.edge[j].dest; \n                int weight = graph.edge[j].weight; \n                if (dist[u] != Integer.MAX_VALUE && dist[u] + weight < dist[v]) \n                    dist[v] = dist[u] + weight; \n            } \n        } \n \n        for (int j = 0; j < E; ++j) { \n            int u = graph.edge[j].src; \n            int v = graph.edge[j].dest; \n            int weight = graph.edge[j].weight; \n            if (dist[u] != Integer.MAX_VALUE && dist[u] + weight < dist[v]) { \n                System.out.println(\"Graph contains negative weight cycle\"); \n                return; \n            } \n        } \n        printArr(dist, V); \n    } \n}"
    },
    {
        "method_name": "bellmanford",
        "method_code": "public class BELLMANFORD {\n \npublic static edge[] getEdges(int numEdges, int[][] graph) {\n\t\tedge[] rv = new edge[numEdges];\n \n\t\tint idx = 0;\n\t\tfor (int u = 1; u < graph.length && idx < rv.length; u++) {\n\t\tfor (int v = 1; v < graph[u].length && idx < rv.length; v++) {\n\t\t\t\trv[idx] = new edge(u, v);\n\t\t\t\tidx = graph[u][v] != 0 ? idx + 1 : idx;\n\t\t\t}\n\t\t}\n \n\t\treturn rv;\n \n\t}\n \npublic static void bellmanford(int src, int nodes, int edges, int[][] graph) {\n\n\t\tHashMap<Integer, Node> nodesMap = new HashMap<>();\n\t\tfor (int i = 1; i < graph.length; i++) {\n            nodesMap.put(i, new Node(i, i == src ? 0 : (int) 1e9 + 1, i == src ? Integer.toString(i) : \"\"));\n\t\t}\n \n\t\tfor (int var = 1; var <= nodes - 1; var++) {\n\t\t\tfor (edge e : getEdges(edges, graph)) {\n\t\t\t\tNode u = nodesMap.get(e.u);\n\t\t\t\tNode v = nodesMap.get(e.v);\n \n\t\t\t\tif (v.dist > u.dist + graph[u.val][v.val]) {\n\t\t\t\t\tv.dist = u.dist + graph[u.val][v.val];\n\t\t\t\t\tv.path = u.path + \"->\" + Integer.toString(v.val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (edge e : getEdges(edges, graph)) {\n\t\t\tNode u = nodesMap.get(e.u);\n\t\t\tNode v = nodesMap.get(e.v);\n\n\t\t\tif (v.dist > u.dist + graph[u.val][v.val]) {\n\t\t\t\tSystem.out.println(\"Negative Cycle Detected\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n \n\t\tfor (int node : nodesMap.keySet()) {\n\t\t\tSystem.out.println(nodesMap.get(node));\n\t\t}\n \n\t}\n \n}\n "
    },
    {
        "method_name": "binarysearch",
        "method_code": "private static int binarySearch(int[] array, int menor, int maior,\n\t\t\tint chave) {\n\t\tint media = (maior + menor) / 2;\n\t\tint valorMeio = array[media];\n\n\t\tif (menor > maior)\n\t\t\treturn -1;\n\t\telse if(valorMeio == chave) \n\t\t\treturn media;\n\t\telse if (valorMeio < chave)\n\t\t\treturn buscaBinariaRecursiva(array, media+1, maior, chave);\n\t\telse\n\t\t\treturn buscaBinariaRecursiva(array, menor, media-1, chave);\n\t}\n"
    },
    {
        "method_name": "binarysearch",
        "method_code": "public static boolean binarySearch(int x, int dados[]){ \n\n  int n = dados.length;     \n  int aux = 0;     \n       \n  for(int i = 0; i < n-1; i++){   \n      for(int j = i+1 ; j < n; j++){\n          if(dados[i] > dados[j]){   \n              aux = dados[j];     \n              dados[j] = dados[i];     \n              dados[i] = aux;     \n          }     \n      }     \n  }     \n       \n  int meio;     \n  int inicio = 0;     \n  int fim = dados.length-1;     \n  while (inicio <= fim) {     \n           meio = (inicio + fim)/2;     \n           if (x == dados[meio])     \n                    return true;     \n           if (x < dados[meio])     \n                    fim = meio - 1;     \n           else     \n                    inicio = meio + 1;     \n  }     \n  return false;     \n\n}\n"
    },
    {
        "method_name": "breadthfirstsearch",
        "method_code": "void BREADTHFIRSTSEARCH(int s) { \n    boolean visited[] = new boolean[V]; \n  \n    LinkedList<Integer> queue = new LinkedList<Integer>(); \n  \n    visited[s]=true; \n    queue.add(s); \n    while (queue.size() != 0) \n    { \n        s = queue.poll(); \n        System.out.print(s+\" \"); \n \n        Iterator<Integer> i = adj[s].listIterator(); \n        while (i.hasNext()) \n        { \n            int n = i.next(); \n            if (!visited[n]) \n            { \n                visited[n] = true; \n                queue.add(n); \n            } \n        } \n    } \n} "
    },
    {
        "method_name": "breadthfirstsearch",
        "method_code": "public class BREADTHFIRSTSEARCH { \n \n\tprivate Queue<Node> queue;\n\tstatic ArrayList<Node> nodes=new ArrayList<Node>();\n\tstatic class Node\n\t{\n\t\tint data;\n\t\tboolean visited;\n\t\tList<Node> neighbours;\n \n\t\tNode(int data)\n\t\t{\n\t\t\tthis.data=data;\n\t\t\tthis.neighbours=new ArrayList<>();\n \n\t\t}\n\t\tpublic void addneighbours(Node neighbourNode)\n\t\t{\n\t\t\tthis.neighbours.add(neighbourNode);\n\t\t}\n\t\tpublic List<Node> getNeighbours() {\n\t\t\treturn neighbours;\n\t\t}\n\t\tpublic void setNeighbours(List<Node> neighbours) {\n\t\t\tthis.neighbours = neighbours;\n\t\t}\n\t}\n \n\tpublic BreadthFirstSearchExampleNeighbourList()\n\t{\n\t\tqueue = new LinkedList<Node>();\n\t}\n \n\tpublic void bfs(Node node)\n\t{\n\t\tqueue.add(node);\n\t\tnode.visited=true;\n\t\twhile (!queue.isEmpty())\n\t\t{\n \n\t\t\tNode element=queue.remove();\n\t\t\tSystem.out.print(element.data + \"t\");\n\t\t\tList<Node> neighbours=element.getNeighbours();\n\t\t\tfor (int i = 0; i < neighbours.size(); i++) {\n\t\t\t\tNode n=neighbours.get(i);\n\t\t\t\tif(n!=null && !n.visited)\n\t\t\t\t{\n\t\t\t\t\tqueue.add(n);\n\t\t\t\t\tn.visited=true;\n \n\t\t\t\t}\n\t\t\t}\n \n\t\t}\n\t}\n}"
    },
    {
        "method_name": "bubblesort",
        "method_code": "private static void bubbleSort(int vetor[]){\n\tboolean troca = true;\n        int aux;\n        while (troca) {\n\t        troca = false;\n                for (int i = 0; i < vetor.length - 1; i++) {\n\t                if (vetor[i] > vetor[i + 1]) {\n\t                \taux = vetor[i];\n\t                \tvetor[i] = vetor[i + 1];\n  \t                \tvetor[i + 1] = aux;\n \t                \ttroca = true;\n                \t}\n\t        }\n\t}\n}\n"
    },
    {
        "method_name": "bubblesort",
        "method_code": "public class BubbleSort {\n \n    public void bubbleSort(int v[]) {\n \n        for (int i = v.length; i >= 1; i--) {\n            for (int j = 1; j < i; j++) {\n                if (v[j - 1] > v[j]) {\n                    int aux = v[j];\n                    v[j] = v[j - 1];\n                    v[j - 1] = aux;\n                }\n            }\n        }\n    }\n}\n"
    },
    {
        "method_name": "bubblesort",
        "method_code": "public static int[] bubbleSort(int vetor[]){\n\tint trocas = 0;\n\tfor (int i = 0; i < vetor.length-1; i++) {\n\t\tif(vetor[i] > vetor[i+1]){\n\t\t\tint temp = vetor[i];\n\t\t\tvetor[i] = vetor[i+1];\n\t\t\tvetor[i+1] = temp;\n\t\t\ttrocas++;\n\t\t}\n\t}\n\tif(trocas != 0)\n\t\tbubbleSort(vetor);\n\treturn vetor;\n}\n"
    },
    {
        "method_name": "bucketsort",
        "method_code": "public class BUCKETSORT {\n\n  public static void bucketSort(int[] input) {\n    final int[] code = hash(input);\n    \n    List[] buckets = new List[code[1]];\n    for (int i = 0; i < code[1]; i++) {\n      buckets[i] = new ArrayList();\n    }\n\n    for (int i : input) {\n      buckets[hash(i, code)].add(i);\n    }\n\n    for (List bucket : buckets) {\n      Collections.sort(bucket);\n    }\n    \n    int ndx = 0;\n    for (int b = 0; b < buckets.length; b++) {\n      for (int v : buckets[b]) {\n        input[ndx++] = v;\n      }\n    }\n  }\n\n  private static int[] hash(int[] input) {\n    int m = input[0];\n    for (int i = 1; i < input.length; i++) {\n      if (m < input[i]) {\n        m = input[i];\n      }\n    }\n    return new int[] { m, (int) Math.sqrt(input.length) };\n  }\n\n  private static int hash(int i, int[] code) {\n    return (int) ((double) i / code[0] * (code[1] - 1));\n  }\n\n}\n"
    },
    {
        "method_name": "bucketsort",
        "method_code": "public class BUCKETSORT {\n    public static void bucketSort(int[] input) {\n\t    final int[] code = hash(input);\n\t    \n\t    List[] buckets = new List[code[1]];\n\t    for (int i = 0; i < code[1]; i++) {\n\t      buckets[i] = new ArrayList();\n\t    }\n\n\t    for (int i : input) {\n\t      buckets[hash(i, code)].add(i);\n\t    }\n\t    \n\t    for (List bucket : buckets) {\n\t      Collections.sort(bucket);\n\t    }\n\t    \n\t    int ndx = 0;\n\n\t    for (int b = 0; b < buckets.length; b++) {\n\t      for (int v : buckets[b]) {\n\t\t\tinput[ndx++] = v;\n\t      }\n\t    }\n\t}\n}\n"
    },
    {
        "method_name": "cocktailshakersort",
        "method_code": "private static void cocktail(int[] vetor) {\n    int tamanho, inicio, fim, swap, aux;\n    tamanho = 10; // para um vetor de 20 elementos\n    inicio = 0;\n    fim = tamanho - 1;\n    swap = 0;\n    while (swap == 0 && inicio < fim)\n    {\n        swap = 1;\n        for (int i = inicio; i < fim; i = i + 1)\n        {\n            if (vetor[i] > vetor[i + 1])\n            {\n                aux = vetor[i];\n                vetor[i] = vetor[i + 1];\n                vetor[i + 1] = aux;\n                swap = 0;\n            }\n        }\n        fim = fim - 1;\n        for (int i = fim; i > inicio; i = i - 1)\n        {\n            if (vetor[i] < vetor[i - 1])\n            {\n                aux = vetor[i];\n                vetor[i] = vetor[i - 1];\n                vetor[i - 1] = aux;\n                swap = 0;\n            }\n        }\n        inicio = inicio + 1;\n    }\n}\n"
    },
    {
        "method_name": "cocktailshakersort",
        "method_code": "class cocktailSort{\n\tvoid cocktailSort(int nums[]) {\n\t\tboolean swapped;\n\t\t  do {\n\t\t\tswapped = false;\n\t\t\tfor (int i =0; i<=  nums.length  - 2;i++) {\n\t\t\t\tif (nums[ i ] > nums[ i + 1 ]) {\n\t\t\t\t\t//test if two elements are in the wrong order\n\t\t\t\t\tint temp = nums[i];\n\t\t\t\t\tnums[i] = nums[i+1];\n\t\t\t\t\tnums[i+1]=temp;\n\t\t\t\t\tswapped = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!swapped) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswapped = false;\n\t\t\tfor (int i= nums.length - 2;i>=0;i--) {\n\t\t\t\tif (nums[ i ] > nums[ i + 1 ]) {\n\t\t\t\t\tint temp = nums[i];\n\t\t\t\t\tnums[i] = nums[i+1];\n\t\t\t\t\tnums[i+1]=temp;\n\t\t\t\t\tswapped = true;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (swapped);\t\t\t\n\t}\n}\n"
    },
    {
        "method_name": "countingsort",
        "method_code": "public static void countingSort(int[] input, int k) { \n  int counter[] = new int[k + 1]; \n\t\n  for (int i = 0; i < counter.length; i++) { counter[i]++; } \n  int ndx = 0; \n  for (int i = 0; i < counter.length; i++) { \n    while (0 < counter[i]) { input[ndx++] = i; \n      counter[i]--; \n    } \n  } \n}\n"
    },
    {
        "method_name": "countingsort",
        "method_code": "public void countingSort(char arr[]) { \n  int n = arr.length; \n  \n  char output[] = new char[n]; \n  int count[] = new int[256];\n\n  for (int i=0; i<256; ++i){ \n    count[i] = 0; \n  }\n  for (int i=0; i<n; ++i) {\n    ++count[arr[i]]; \n  }\n  for (int i=1; i<=255; ++i){ \n    count[i] += count[i-1]; \n  }\n  for (int i = n-1; i>=0; i--) { \n    output[count[arr[i]]-1] = arr[i]; \n    --count[arr[i]]; \n  } \n  \n  for (int i = 0; i<n; ++i){ \n    arr[i] = output[i]; \n  }\n}\n"
    },
    {
        "method_name": "countingsort",
        "method_code": "public void countingSort(Integer[] array, int leftIndex, int rightIndex) {\n\t\t\n  int k = 0;\n  for(int m = leftIndex; m < rightIndex; m++){\n    if(array[m] > k){\n      k = array[m];\n    }\n  }\n  \n  int[] vetorTemporario = new int[k];\n  \n  for(int i = 0; i < vetorTemporario.length; i++){\n    vetorTemporario[i] = 0;\n  }\n  \n  for(int j = leftIndex; j < rightIndex; j++){\n    vetorTemporario[array[j]] += 1;\n  }\n  \n  for(int i = leftIndex; i < k; i++){\n    vetorTemporario[i] = vetorTemporario[i] + vetorTemporario[i - 1];\n  }\n  \n  int[] vetorAuxiliar = new int[array.length];\n  for(int j = rightIndex; j > leftIndex; j--) {\n    vetorAuxiliar[vetorTemporario[array[j]]] = array[j];\n    vetorTemporario[array[j]] -= 1; \n  }\n  \n  for (int i = leftIndex; i < rightIndex; i++){\n    array[i] = vetorAuxiliar[i];\n  }\n}\n"
    },
    {
        "method_name": "depthfirstsearch",
        "method_code": "public class DepthFirstSearch {\n  void DFSUtil(int v,boolean visited[]) { \n    visited[v] = true; \n    System.out.print(v+\" \"); \n    \n    Iterator<Integer> i = adj[v].listIterator(); \n    while (i.hasNext()) { \n      int n = i.next(); \n      if (!visited[n]) \n        DFSUtil(n, visited); \n    } \n  } \n\n  void DFS(int v) { \n    boolean visited[] = new boolean[V];  \n    DFSUtil(v, visited); \n  } \n}"
    },
    {
        "method_name": "depthfirstsearch",
        "method_code": "public class DepthFirstSearch {\n  void DFSUtil(int v,boolean visited[]) { \n    visited[v] = true; \n    System.out.print(v+\" \"); \n    \n    Iterator<Integer> i = adj[v].listIterator(); \n    while (i.hasNext()) { \n      int n = i.next(); \n      if (!visited[n]) \n        DFSUtil(n,visited); \n    } \n  } \n  void DFS() { \n    boolean visited[] = new boolean[V]; \n    for (int i=0; i<V; ++i) \n      if (visited[i] == false) \n        DFSUtil(i, visited); \n  } \n}"
    },
    {
        "method_name": "dijkstra",
        "method_code": "public class DIJKSTRA {\n\n\tList<Vertice> menorCaminho = new ArrayList<Vertice>();\n\n\tVertice verticeCaminho = new Vertice();\n\n\tVertice atual = new Vertice();\n\n\tVertice vizinho = new Vertice();\n\n\tList<Vertice> naoVisitados = new ArrayList<Vertice>();\n\n\tpublic List<Vertice> encontrarMenorCaminhoDijkstra(Grafo grafo, Vertice v1,\n\t\t\tVertice v2) {\n\n\t\tmenorCaminho.add(v1);\n\n\t\tfor (int i = 0; i < grafo.getVertices().size(); i++) {\n\t\t\tif (grafo.getVertices().get(i).getDescricao()\n\t\t\t\t\t.equals(v1.getDescricao())) {\n\n\t\t\t\tgrafo.getVertices().get(i).setDistancia(0);\n\n\t\t\t} else {\n\n\t\t\t\tgrafo.getVertices().get(i).setDistancia(9999);\n\n\t\t\t}\n\t\t\tthis.naoVisitados.add(grafo.getVertices().get(i));\n\t\t}\n\n\t\tCollections.sort(naoVisitados);\n\t\twhile (!this.naoVisitados.isEmpty()) {\n\t\t\tatual = this.naoVisitados.get(0);\n\t\t\tSystem.out.println(\"Pegou esse vertice:  \" + atual);\n\t\t\tfor (int i = 0; i < atual.getArestas().size(); i++) {\n\n\t\t\t\tvizinho = atual.getArestas().get(i).getDestino();\n\t\t\t\tSystem.out.println(\"Olhando o vizinho de \" + atual + \": \"\n\t\t\t\t\t\t+ vizinho);\n\t\t\t\tif (!vizinho.verificarVisita()) {\n\t\t\t\t\tif (vizinho.getDistancia() > (atual.getDistancia() + atual\n\t\t\t\t\t\t\t.getArestas().get(i).getPeso())) {\n\n\t\t\t\t\t\tvizinho.setDistancia(atual.getDistancia()\n\t\t\t\t\t\t\t\t+ atual.getArestas().get(i).getPeso());\n\t\t\t\t\t\tvizinho.setPai(atual);\n\t\t\t\t\t\tif (vizinho == v2) {\n\t\t\t\t\t\t\tmenorCaminho.clear();\n\t\t\t\t\t\t\tverticeCaminho = vizinho;\n\t\t\t\t\t\t\tmenorCaminho.add(vizinho);\n\t\t\t\t\t\t\twhile (verticeCaminho.getPai() != null) {\n\n\t\t\t\t\t\t\t\tmenorCaminho.add(verticeCaminho.getPai());\n\t\t\t\t\t\t\t\tverticeCaminho = verticeCaminho.getPai();\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tCollections.sort(menorCaminho);\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tatual.visitar();\n\t\t\tthis.naoVisitados.remove(atual);\n\t\t\tCollections.sort(naoVisitados);\n\t\t\tSystem.out.println(\"Nao foram visitados ainda:\"+naoVisitados);\n\n\t\t}\n\n\t\treturn menorCaminho;\n\t}\n\n}"
    },
    {
        "method_name": "dijkstra",
        "method_code": "public class DIJKSTRA { \n\tprivate int dist[]; \n\tprivate Set<Integer> settled; \n\tprivate PriorityQueue<Node> pq; \n\tprivate int V; \n\tList<List<Node> > adj; \n\n\tpublic DPQ(int V) \n\t{ \n\t\tthis.V = V; \n\t\tdist = new int[V]; \n\t\tsettled = new HashSet<Integer>(); \n\t\tpq = new PriorityQueue<Node>(V, new Node()); \n\t} \n\n\tpublic void dijkstra(List<List<Node> > adj, int src) \n\t{ \n\t\tthis.adj = adj; \n\n\t\tfor (int i = 0; i < V; i++) \n\t\t\tdist[i] = Integer.MAX_VALUE; \n\n\t\tpq.add(new Node(src, 0)); \n\n\t\tdist[src] = 0; \n\t\twhile (settled.size() != V) { \n\n\t\t\tint u = pq.remove().node; \n\n\t\t\tsettled.add(u); \n\n\t\t\te_Neighbours(u); \n\t\t} \n\t} \n\n\tprivate void e_Neighbours(int u) \n\t{ \n\t\tint edgeDistance = -1; \n\t\tint newDistance = -1; \n\n\t\tfor (int i = 0; i < adj.get(u).size(); i++) { \n\t\t\tNode v = adj.get(u).get(i); \n\n\t\t\tif (!settled.contains(v.node)) { \n\t\t\t\tedgeDistance = v.cost; \n\t\t\t\tnewDistance = dist[u] + edgeDistance; \n\n\t\t\t\tif (newDistance < dist[v.node]) \n\t\t\t\t\tdist[v.node] = newDistance; \n\n\t\t\t\tpq.add(new Node(v.node, dist[v.node])); \n\t\t\t} \n\t\t} \n\t} \n}\n"
    },
    {
        "method_name": "editdistance",
        "method_code": "public static int editDistance(String word1, String word2) {\n\tint len1 = word1.length();\n\tint len2 = word2.length();\n \n\t// len1+1, len2+1, because finally return dp[len1][len2]\n\tint[][] dp = new int[len1 + 1][len2 + 1];\n \n\tfor (int i = 0; i <= len1; i++) {\n\t\tdp[i][0] = i;\n\t}\n \n\tfor (int j = 0; j <= len2; j++) {\n\t\tdp[0][j] = j;\n\t}\n \n\t//iterate though, and check last char\n\tfor (int i = 0; i < len1; i++) {\n\t\tchar c1 = word1.charAt(i);\n\t\tfor (int j = 0; j < len2; j++) {\n\t\t\tchar c2 = word2.charAt(j);\n \n\t\t\t//if last two chars equal\n\t\t\tif (c1 == c2) {\n\t\t\t\t//update dp value for +1 length\n\t\t\t\tdp[i + 1][j + 1] = dp[i][j];\n\t\t\t} else {\n\t\t\t\tint replace = dp[i][j] + 1;\n\t\t\t\tint insert = dp[i][j + 1] + 1;\n\t\t\t\tint delete = dp[i + 1][j] + 1;\n \n\t\t\t\tint min = replace > insert ? insert : replace;\n\t\t\t\tmin = delete > min ? min : delete;\n\t\t\t\tdp[i + 1][j + 1] = min;\n\t\t\t}\n\t\t}\n\t}\n \n\treturn dp[len1][len2];\n}\n"
    },
    {
        "method_name": "editdistance",
        "method_code": "public int editDistance(String word1, String word2) {\n  int m=word1.length();\n  int n=word2.length();\n  int[][] mem = new int[m][n];\n  for(int[] arr: mem){\n      Arrays.fill(arr, -1);\n  }\n  return calDistance(word1, word2, mem, m-1, n-1);\n}\n\nprivate int calDistance(String word1, String word2, int[][] mem, int i, int j){ \n  if(i<0){\n      return j+1;\n  }else if(j<0){\n      return i+1;\n  }\n\n  if(mem[i][j]!=-1){\n      return mem[i][j];\n  }\n\n  if(word1.charAt(i)==word2.charAt(j)){\n      mem[i][j]=calDistance(word1, word2, mem, i-1, j-1);\n  }else{\n      int prevMin = Math.min(calDistance(word1, word2, mem, i, j-1), calDistance(word1, word2, mem, i-1, j));\n      prevMin = Math.min(prevMin, calDistance(word1, word2, mem, i-1, j-1));\n      mem[i][j]=1+prevMin;\n  }\n\n  return mem[i][j];    \n}\n"
    },
    {
        "method_name": "fibonacci",
        "method_code": "public class Fibonacci {\n  \n  static long fibo(int n) {\n      if (n < 2) {\n          return n;\n      } else {\n          return fibo(n - 1) + fibo(n - 2);\n      }\n  }\n}"
    },
    {
        "method_name": "fibonacci",
        "method_code": "public class Fibonacci {\n  \n  static long fibo(int n) {\n      return (n < 2) ? n : fibo(n - 1) + fibo(n - 2);\n  }\n}"
    },
    {
        "method_name": "fibonacci",
        "method_code": "public class Fibonacci {    \n \n  private static int[] vetAux = new int[50];\n  private static int k;\n\n  public static long fibo(int n) {      \n           k = 1; // inicializa k\n           return recursao(n);\n         }\n\n  private static long recursao(int n) {\n          if (n < 0) { \n             return vetAux[0];  \n        } else { \n         if (k < 3) {\n            vetAux[n] = k - 1; \n            k++; \n         } else {\n               vetAux[n] = vetAux[n + 1] + vetAux[n + 2]; \n               }\n            return recursao(n - 1);\n         }\n  }\n}"
    },
    {
        "method_name": "fordfulkerson",
        "method_code": "int fordFulkerson(int graph[][], int s, int t) { \n\t\t  int u, v;\n\t\t  int rGraph[][]; \n\t\t  for (u = 0; u < V; u++) \n\t\t    for (v = 0; v < V; v++) \n\t\t      rGraph[u][v] = graph[u][v]; \n\t\t  int parent[]; \n\t\t  int max_flow = 0;  \n\t\t  while (bfs(rGraph, s, t, parent)) \n\t\t  { \n\t\t    int path_flow = INT_MAX; \n\t\t    for (v=t; v!=s; v=parent[v]) { \n\t\t      u = parent[v]; \n\t\t      path_flow = min(path_flow, rGraph[u][v]); \n\t\t    } \n\t\t    for (v=t; v != s; v=parent[v]) { \n\t\t      u = parent[v]; \n\t\t      rGraph[u][v] -= path_flow; \n\t\t      rGraph[v][u] += path_flow; \n\t\t    } \n\t\t    max_flow += path_flow; \n\t\t  } \n\t\t  return max_flow; \n\t} \n\n"
    },
    {
        "method_name": "fordfulkerson",
        "method_code": "public int fordFulkerson(int graph[][], int vertexS, int vertexT) {\n  int maxFlow = 0;\n  int parent[] = new int[vertexCount];\t\n  int vertexU=0;\t\n  int vertexV =0;\n\n  int residualGraph[][] = new int[vertexCount][vertexCount];\n  for (vertexU = 0; vertexU < vertexCount; vertexU++){\t\t\n    for (vertexV = 0; vertexV < vertexCount; vertexV++){\n      residualGraph[vertexU][vertexV] = graph[vertexU][vertexV];\n    }\n  }\n\n  while (bfs(residualGraph, vertexS, vertexT, parent)) {\t\t\n    String pathString = \"\";\t\t\n\n    int bottleneckFlow = Integer.MAX_VALUE;\t\n    for (vertexV=vertexT; vertexV != vertexS; vertexV=parent[vertexV]) {\t\t\n      vertexU = parent[vertexV];\t\t\n      bottleneckFlow = Math.min(bottleneckFlow, residualGraph[vertexU][vertexV]);\t\t\n\n      pathString = \" --> \"+arrayIndexStringEquivalents[vertexV]+ pathString;\n    }\n    pathString= \"S\"+pathString;\t\t\n    System.out.println(\"Augmentation path \\n\"+pathString);\n    System.out.println(\"bottleneck (min flow on path added to max flow) = \"+bottleneckFlow +\"\\n\");\n\n    for (vertexV=vertexT; vertexV != vertexS; vertexV=parent[vertexV]) {\n      vertexU = parent[vertexV];\n      residualGraph[vertexU][vertexV] -= bottleneckFlow;\t\n      residualGraph[vertexV][vertexU] += bottleneckFlow;\t\t\n    }\n\n    maxFlow += bottleneckFlow;\t\t\n  }\n\n  return maxFlow;\n}\n"
    },
    {
        "method_name": "gnomesort",
        "method_code": "public static Integer[] gnomeSort(Integer[] array){\n  int pivout = 0;\n  int aux;\n  while(pivout<(array.length-1)){\n    if(array[pivout]>array[pivout+1]){\n      aux = array[pivout];\n      array[pivout] = array[pivout+1];\n      array[pivout+1] = aux;\n      if(pivout>0){\n        pivout-=2;\n      }\n    }\n    pivout++;\n  }\n  return array;\n}"
    },
    {
        "method_name": "gnomesort",
        "method_code": "public class GnomeSort<E extends Comparable<? super E>> {\n\n  public Collection<E> sort(Collection<E> vector) {\n\n      int i = 1;\n      List<E> result = new ArrayList<E>(vector);\n\n      while (i < result.size()) {\n\n          if (i == 0 || result.get(i - 1).compareTo(result.get(i))<= 0) {\n              i++;\n          } else {\n              E temp = result.get(i - 1);\n\n              result.set(i - 1, result.get(i));\n\n              result.set(i, temp);\n              i--;\n          }\n      }\n\n      return result;\n  }\n}"
    },
    {
        "method_name": "hamiltoniancycle",
        "method_code": "public class HamiltonianCycle {\n  boolean isSafe(int v, int graph[][], int path[], int pos) { \n    if (graph[path[pos - 1]][v] == 0) \n      return false; \n\n    for (int i = 0; i < pos; i++) \n      if (path[i] == v) \n        return false; \n    \n    return true; \n  } \n\n  boolean hamCycleUtil(int graph[][], int path[], int pos) { \n    if (pos == V) { \n      if (graph[path[pos - 1]][path[0]] == 1) \n        return true; \n      else\n        return false; \n    } \n    for (int v = 1; v < V; v++) { \n      if (isSafe(v, graph, path, pos)) { \n        path[pos] = v; \n        if (hamCycleUtil(graph, path, pos + 1) == true) \n          return true; \n        path[pos] = -1; \n      } \n    } \n    return false; \n  } \n\n  int hamCycle(int graph[][]) { \n    path = new int[V]; \n    for (int i = 0; i < V; i++) \n      path[i] = -1; \n    path[0] = 0; \n    if (hamCycleUtil(graph, path, 1) == false) { \n      System.out.println(\"\\nSolution does not exist\"); \n      return 0; \n    } \n    printSolution(path); \n    return 1; \n  }\n}\n"
    },
    {
        "method_name": "hamiltoniancycle",
        "method_code": "public class HamiltonianCycle {\n  int verticesNum;\n  char[] vertices;\n  char[] path;\n  int size;\n  Map<Character,Integer> vertexIndexMap = new HashMap<>();\n  public HamiltonianCycle(int verticesNum) {\n      this.verticesNum = verticesNum;\n      vertices = new char[verticesNum];\n      path = new char[verticesNum];\n  }\n\n  public void addVertex(char v) {\n      vertexIndexMap.put(v, size);\n      vertices[size++] = v;\n  }\n\n  private boolean isValidNodeInPath(int [][] graph, int indexOfNewVerex ,int pos) {\n      char lastVertexInPath = path[pos-1];\n      int indexOfLastVertexInPath = vertexIndexMap.get(lastVertexInPath);\n      if(graph[indexOfNewVerex][indexOfLastVertexInPath] == 0){\n          return false;\n      }\n      for(int i = 0; i < pos; i++){ \n          if(vertices[indexOfNewVerex] == path[i]){\n              return false;\n          }\n      }\n      return true;\n  }\n\n  private boolean validateHamiltonianCycleUtil(int [][] graph, int pos){\n      // base condition\n      if(pos == verticesNum){\n          char lastVertexInPath = path[pos-1];\n          int indexOfVertexlastInPath = vertexIndexMap.get(lastVertexInPath);\n          if(graph[0][indexOfVertexlastInPath] == 1){\n              return true;\n          }\n          else {\n              return false;\n          }\n      }\n      for(int i = 1; i < verticesNum; i++){\n          if(isValidNodeInPath(graph,i,pos)){\n              path[pos] = vertices[i];\n              if(validateHamiltonianCycleUtil(graph, pos+1)){\n                  return true;\n              }\n              path[pos] = '$';\n          }\n      }\n      \n      return false;\n  }\n\n  public boolean isHamiltonianCycle(int[][] graph) {\n      for (int i = 0; i < verticesNum; i++) {\n          path[i] = '$';\n      }\n      path[0] = vertices[0]; \n      if (validateHamiltonianCycleUtil(graph, 1)) {\n          \n          System.out.println(\"Path exists::\");\n          for(int i = 0 ; i < verticesNum; i++){\n              System.out.print(path[i]+\" \");\n          }\n          System.out.print(path[0]);\n          return true;\n      }\n      System.out.println(\"No path exists!!\");\n      return false;\n  }\n}"
    },
    {
        "method_name": "heapsort",
        "method_code": "public class HEAPSORT { \n    public void sort(int arr[]) \n    { \n        int n = arr.length; \n  \n        for (int i = n / 2 - 1; i >= 0; i--) \n            heapify(arr, n, i); \n  \n\n        for (int i=n-1; i>0; i--) \n        { \n\n            int temp = arr[0]; \n            arr[0] = arr[i]; \n            arr[i] = temp; \n\n            heapify(arr, i, 0); \n        } \n    } \n  \n    void heapify(int arr[], int n, int i) \n    { \n        int largest = i; \n        int l = 2*i + 1;\n        int r = 2*i + 2; \n  \n        if (l < n && arr[l] > arr[largest]) \n            largest = l; \n  \n        if (r < n && arr[r] > arr[largest]) \n            largest = r; \n  \n        if (largest != i) \n        { \n            int swap = arr[i]; \n            arr[i] = arr[largest]; \n            arr[largest] = swap; \n  \n            heapify(arr, n, largest); \n        } \n    } \n}"
    },
    {
        "method_name": "heapsort",
        "method_code": "public class HEAPSORT {\n    void heapify(int arr[], int size, int i)  \n    {  \n        int largest = i;    \n        int left = 2*i + 1;    \n        int right = 2*i + 2;    \n        \n        if (left < size && arr[left] >arr[largest])  \n            largest = left;  \n        \n        if (right < size && arr[right] > arr[largest])  \n            largest = right;  \n        \n        if (largest != i)  \n        {  \n            temp = arr[i];  \n            arr[i]= arr[largest];   \n            arr[largest] = temp;  \n            heapify(arr, size, largest);  \n        }  \n    }  \n        \n    void heapSort(int arr[], int size)  {  \n        int i;  \n        for (i = size / 2 - 1; i >= 0; i--)  \n        heapify(arr, size, i);  \n        for (i=size-1; i>=0; i--)  \n        {  \n        temp = arr[0];  \n            arr[0]= arr[i];   \n            arr[i] = temp;  \n        heapify(arr, i, 0);  \n        }  \n    }  \n}"
    },
    {
        "method_name": "insertionsort",
        "method_code": "public static void insertionSort(int[] vetor) {\n    int j;\n    int key;\n    int i;\n    \n    for (j = 1; j < vetor.length; j++)\n    {\n      key = vetor[j];\n      for (i = j - 1; (i >= 0) && (vetor[i] > key); i--)\n      {\n         vetor[i + 1] = vetor[i];\n       }\n        vetor[i + 1] = key;\n    }\n}\n"
    },
    {
        "method_name": "insertionsort",
        "method_code": "void insertionSort(int arr[]) \n    { \n        int n = arr.length; \n        for (int i = 1; i < n; ++i) { \n            int key = arr[i]; \n            int j = i - 1; \n  \n            while (j >= 0 && arr[j] > key) { \n                arr[j + 1] = arr[j]; \n                j = j - 1; \n            } \n            arr[j + 1] = key; \n        } \n    } \n"
    },
    {
        "method_name": "insertionsort",
        "method_code": "public static void insertionSort(int array[]) {  \n\tint n = array.length;  \n        for (int j = 1; j < n; j++) {  \n            int key = array[j];  \n            int i = j-1;  \n            while ( (i > -1) && ( array [i] > key ) ) {  \n                array [i+1] = array [i];  \n                i--;  \n            }  \n            array[i+1] = key;  \n\t}  \n}  \n"
    },
    {
        "method_name": "interpolationsearch",
        "method_code": "public int interpolationSearch(int[] data, int item) {\n \n  int highEnd = (data.length - 1);\n  int lowEnd = 0;\n\n  while (item >= data[lowEnd] && item <= data[highEnd] && lowEnd <= highEnd) {\n\n      int probe\n        = lowEnd + (highEnd - lowEnd) * (item - data[lowEnd]) / (data[highEnd] - data[lowEnd]);\n\n      if (highEnd == lowEnd) {\n          if (data[lowEnd] == item) {\n              return lowEnd;\n          } else {\n              return -1;\n          }\n      }\n\n      if (data[probe] == item) {\n          return probe;\n      }\n\n      if (data[probe] < item) {\n          lowEnd = probe + 1;\n      } else {\n          highEnd = probe - 1;\n      }\n  }\n  return -1;\n}"
    },
    {
        "method_name": "interpolationsearch",
        "method_code": "static int interpolationSearch(int x) \n    { \n        // Find indexes of two corners \n        int lo = 0, hi = (arr.length - 1); \n       \n        // Since array is sorted, an element present \n        // in array must be in range defined by corner \n        while (lo <= hi && x >= arr[lo] && x <= arr[hi]) \n        {         \n  \n            if (lo == hi) \n            { \n                if (arr[lo] == x) return lo; \n                return -1; \n            } \n         \n            // Probing the position with keeping \n            // uniform distribution in mind. \n              \n            int pos = lo + (((hi-lo) / \n                  (arr[hi]-arr[lo]))*(x - arr[lo])); \n       \n            // Condition of target found \n            if (arr[pos] == x) \n                return pos; \n       \n            // If x is larger, x is in upper part \n            if (arr[pos] < x) \n                lo = pos + 1; \n       \n            // If x is smaller, x is in the lower part \n            else\n                hi = pos - 1; \n        } \n        return -1; \n    } "
    },
    {
        "method_name": "jumpsearch",
        "method_code": "public static int jumpSearch(int[] arr, int x) \n    { \n        int n = arr.length; \n  \n        // Finding block size to be jumped \n        int step = (int)Math.floor(Math.sqrt(n)); \n  \n        // Finding the block where element is \n        // present (if it is present) \n        int prev = 0; \n        while (arr[Math.min(step, n)-1] < x) \n        { \n            prev = step; \n            step += (int)Math.floor(Math.sqrt(n)); \n            if (prev >= n) \n                return -1; \n        } \n  \n        // Doing a linear search for x in block \n        // beginning with prev. \n        while (arr[prev] < x) \n        { \n            prev++; \n  \n            // If we reached next block or end of \n            // array, element is not present. \n            if (prev == Math.min(step, n)) \n                return -1; \n        } \n  \n        // If element is found \n        if (arr[prev] == x) \n            return prev; \n  \n        return -1; \n    } "
    },
    {
        "method_name": "jumpsearch",
        "method_code": "public static int jumpSearch(int[] arr, int item){\n\t        \n \tint array_size = arr.length;\n  int block_size = (int)Math.floor(Math.sqrt(array_size));\n\tint prev = 0;\n\twhile (arr[Math.min(block_size, array_size)-1] < item){\n\t  prev = block_size;\n\t  block_size += (int)Math.floor(Math.sqrt(array_size));\n\t  if (prev >= array_size)\n\t    return -1;\n\t}\n\twhile (arr[prev] < item){\n\t  prev++;\n\t  if (prev == Math.min(block_size, array_size))\n\t    return -1;\n\t  }\n\t  if (arr[prev] == item)\n\t    return prev;\n\t  return -1;\n}\n"
    },
    {
        "method_name": "kadane",
        "method_code": "public class KadaneAlgorithm {\n\t\n\tstatic int largestContiguousSum(int arr[]){\n\t\tint i,len=arr.length,cursum=0,maxsum=Integer.MIN_VALUE;\n\t\tif(len==0)\n\t\t\treturn 0;\n\t\tfor(i=0;i<len;i++){\n\t\t\tcursum+=arr[i];\n\t\t\tif(cursum>maxsum){\n\t\t\t\tmaxsum=cursum;\n\t\t\t}\n\t\t\tif(cursum<=0){\n\t\t\t\tcursum=0;\n\t\t\t}\n\t\t}\n\t\treturn maxsum;\n  }\n}"
    },
    {
        "method_name": "kruskal",
        "method_code": "public class KRUSKAL {\n    void KruskalMST() \n    { \n        Edge result[] = new Edge[V]; \n        int e = 0;  \n        int i = 0;  \n        for (i=0; i<V; ++i) \n            result[i] = new Edge(); \n \n        Arrays.sort(edge); \n\n        subset subsets[] = new subset[V]; \n        for(i=0; i<V; ++i) \n            subsets[i]=new subset(); \n  \n         for (int v = 0; v < V; ++v) \n        { \n            subsets[v].parent = v; \n            subsets[v].rank = 0; \n        } \n  \n        i = 0; \n\n        while (e < V - 1) \n        { \n            Edge next_edge = new Edge(); \n            next_edge = edge[i++]; \n  \n            int x = find(subsets, next_edge.src); \n            int y = find(subsets, next_edge.dest); \n  \n\n            if (x != y) \n            { \n                result[e++] = next_edge; \n                Union(subsets, x, y); \n            } \n \n        } \n\n        System.out.println(\"Following are the edges in \" +  \n                                     \"the constructed MST\"); \n        for (i = 0; i < e; ++i) \n            System.out.println(result[i].src+\" -- \" +  \n                   result[i].dest+\" == \" + result[i].weight); \n    } \n}"
    },
    {
        "method_name": "kruskal",
        "method_code": "public class KRUSKAL {\n \n\tpublic static void kruskalsAlgo(int numVertices, int numEdges, edge[] edges, int[][] graph) {\n \n\t\tint[][] mst = new int[graph.length][graph.length];\n\t\tArrays.sort(edges);\n \n\t\tint[] parents = new int[numVertices + 1];\n\t\tint[] size = new int[numVertices + 1];\n\t\tfor (int vertex = 1; vertex < graph.length; vertex++) {\n\t\t\tparents[vertex] = vertex;\n\t\t\tsize[vertex] = 1;\n\t\t}\n \n\t\tint edgeCounter = 0;\n\t\tint edgedTaken = 1;\n\t\twhile (edgedTaken <= numVertices - 1) {\n\t\t\tedge e = edges[edgeCounter];\n\t\t\tedgeCounter++;\n\t\t\tif (isCyclic(e.u, e.v, parents))\n\t\t\t\tcontinue;\n\t\t\tunion(findParent(e.u, parents), findParent(e.v, parents), parents, size);\n\t\t\tmst[e.u][e.v] = e.weight;\n\t\t\tedgedTaken++;\n\t\t}\n\n\t\tfor (int u = 1; u < mst.length; u++) {\n\t\t\tfor (int v = 0; v < mst.length; v++) {\n\t\t\t\tif (mst[u][v] != 0) {\n\t\t\t\t\tSystem.out.println(u + \" \" + v + \" \" + mst[u][v]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n \n\t}\n}"
    },
    {
        "method_name": "levenshteindistance",
        "method_code": "public class LevenshteinDistance {\n \n  static int calculate(String x, String y) {\n       if (x.isEmpty()) {\n           return y.length();\n       }\n\n       if (y.isEmpty()) {\n           return x.length();\n       } \n\n       int substitution = calculate(x.substring(1), y.substring(1)) \n        + costOfSubstitution(x.charAt(0), y.charAt(0));\n       int insertion = calculate(x, y.substring(1)) + 1;\n       int deletion = calculate(x.substring(1), y) + 1;\n\n       return min(substitution, insertion, deletion);\n   }\n\n   public static int costOfSubstitution(char a, char b) {\n       return a == b ? 0 : 1;\n   }\n\n   public static int min(int... numbers) {\n       return Arrays.stream(numbers)\n         .min().orElse(Integer.MAX_VALUE);\n   }\n}\n"
    },
    {
        "method_name": "levenshteindistance",
        "method_code": "static int LevenshteinDistance(String x, String y) {\n  int[][] dp = new int[x.length() + 1][y.length() + 1];\n\n  for (int i = 0; i <= x.length(); i++) {\n      for (int j = 0; j <= y.length(); j++) {\n          if (i == 0) {\n              dp[i][j] = j;\n          }\n          else if (j == 0) {\n              dp[i][j] = i;\n          }\n          else {\n              dp[i][j] = min(dp[i - 1][j - 1] \n               + costOfSubstitution(x.charAt(i - 1), y.charAt(j - 1)), \n                dp[i - 1][j] + 1, \n                dp[i][j - 1] + 1);\n          }\n      }\n  }\n\n  return dp[x.length()][y.length()];\n}\n"
    },
    {
        "method_name": "linearsearch",
        "method_code": "public static int linearSearch(int arr[], int x) \n{ \n  int n = arr.length; \n  for(int i = 0; i < n; i++) { \n    if(arr[i] == x) \n      return i; \n  } \n  return -1; \n} \n"
    },
    {
        "method_name": "linearsearch",
        "method_code": "public static int linearSearch(int arr[]){\n  for(int i = 0; i<arr.length; i++){  \n    if(arr[i]==item){  \n      flag = i+1;  \n      break;  \n    }  \n    else{   \n      flag = 0;   \n    }\n  }  \n  if(flag != 0)  \n  {  \n      System.out.println(\"Item found at location\" + flag);  \n  }  \n  else   {\n      System.out.println(\"Item not found\");\n  }\n}\n"
    },
    {
        "method_name": "longestcommonsubsequence",
        "method_code": "public class LongestCommonSubsequence { \n  \n  /* Returns length of LCS for X[0..m-1], Y[0..n-1] */\n  int lcs(char[] X, char[] Y, int m, int n) \n  { \n      if (m == 0 || n == 0) \n          return 0; \n      if (X[m - 1] == Y[n - 1]) \n          return 1 + lcs(X, Y, m - 1, n - 1); \n      else\n          return max(lcs(X, Y, m, n - 1), lcs(X, Y, m - 1, n)); \n  } \n\n  /* Utility function to get max of 2 integers */\n  int max(int a, int b) \n  { \n      return (a > b) ? a : b; \n  } \n}"
    },
    {
        "method_name": "longestcommonsubsequence",
        "method_code": "public static int longestCommonSubsequence(String a, String b){\n\tint m = a.length();\n\tint n = b.length();\n\tint[][] dp = new int[m+1][n+1];\n \n\tfor(int i=0; i<=m; i++){\n\t\tfor(int j=0; j<=n; j++){\n\t\t\tif(i==0 || j==0){\n\t\t\t\tdp[i][j]=0;\n\t\t\t}else if(a.charAt(i-1)==b.charAt(j-1)){\n\t\t\t\tdp[i][j] = 1 + dp[i-1][j-1];\n\t\t\t}else{\n\t\t\t\tdp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\n\t\t\t}\n\t\t}\n\t}\n \n\treturn dp[m][n];\n}\n"
    },
    {
        "method_name": "longestincreasingsubsequence",
        "method_code": "class LongestCommonSubsequence \n{ \n   static int max_ref; \n   static int _lis(int arr[], int n) \n   { \n       if (n == 1) \n           return 1; \n  \n       int res, max_ending_here = 1; \n\n        for (int i = 1; i < n; i++) \n        { \n            res = _lis(arr, i); \n            if (arr[i-1] < arr[n-1] && res + 1 > max_ending_here) \n                max_ending_here = res + 1; \n        } \n\n        if (max_ref < max_ending_here) \n           max_ref = max_ending_here; \n  \n        return max_ending_here; \n   } \n  \n    static int lis(int arr[], int n) \n    { \n        max_ref = 1; \n  \n        _lis( arr, n); \n  \n        return max_ref; \n    } \n  }\n"
    },
    {
        "method_name": "longestincreasingsubsequence",
        "method_code": "public int longestCommonSubsequence(int[] nums) {\n  if(nums==null || nums.length==0)\n      return 0;\n\n  int[] max = new int[nums.length];\n  Arrays.fill(max, 1);\n\n  int result = 1;\n  for(int i=0; i<nums.length; i++){\n      for(int j=0; j<i; j++){\n          if(nums[i]>nums[j]){\n              max[i]= Math.max(max[i], max[j]+1);\n\n          }\n      }\n      result = Math.max(max[i], result);\n  }\n\n return result;\n}\n"
    },
    {
        "method_name": "longestpathindirectedacyclicgraph",
        "method_code": "public class LongestPathInDirectedAcyclicGraph {\n\n\tpublic static void find(int[][] graph, int v) {\n\t\tStack<Integer> stack = TopologicalSorting.sort(graph);\n\t\tint[] dis = new int[graph.length];\n\t\tArrays.fill(dis, Integer.MIN_VALUE);\n\t\tdis[v] = 0; \n\t\twhile (!stack.isEmpty()) {\n\t\t\tint ver = stack.pop();\n\t\t\tif (dis[ver] != Integer.MIN_VALUE) {\n\t\t\t\tfor (int i = 0; i < graph.length; i++) {\n\t\t\t\t\tif (graph[ver][i] != 0) {\n\t\t\t\t\t\tif (dis[i] < graph[ver][i] + dis[ver]) {\n\t\t\t\t\t\t\tdis[i] = graph[ver][i] + dis[ver];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int d : dis)\n\t\t\tSystem.out.print(d + \" \");\n\t}\n}"
    },
    {
        "method_name": "longestvalidparenthesis",
        "method_code": "public int longestValidParentheses(String s) {\n  Stack<Integer> stack = new Stack<>();\n  int res = 0;\n  int start = -1;\n  for (int i = 0; i < s.length(); i++) {\n    if (s.charAt(i) == '(') {\n      stack.push(i);\n    } else {\n      if (stack.isEmpty()) {\n        start = i;\n      } else {\n        stack.pop();\n        if (stack.isEmpty()) {\n          res = Math.max(res, i - start);\n        } else {\n          res = Math.max(res, i - stack.peek());\n        }\n      }\n    }\n  }\n  return res;\n}"
    },
    {
        "method_name": "longestvalidparenthesis",
        "method_code": "public int longestValidParentheses(String s) {\n  Stack<int[]> stack = new Stack<>();\n  int result = 0;\n\n  for(int i=0; i<s.length(); i++){\n      char c = s.charAt(i);\n      if(c==')'){\n          if(!stack.isEmpty() && stack.peek()[0]==0){\n              stack.pop();\n              result = Math.max(result, i-(stack.isEmpty()?-1:stack.peek()[1]));\n          }else{\n              stack.push(new int[]{1, i});\n          }\n      }else{\n          stack.push(new int[]{0, i});\n      }\n  }\n\n  return result;\n}"
    },
    {
        "method_name": "matrixchainmultiplication",
        "method_code": "static int matrixChainMultiplication(int p[], int i, int j) { \n  if (i == j) \n    return 0; \n  \n  int min = Integer.MAX_VALUE; \n\n  for (int k = i; k < j; k++) { \n    int count = MatrixChainOrder(p, i, k) +  \n                MatrixChainOrder(p, k + 1, j) +  \n                p[i - 1] * p[k] * p[j]; \n  \n    if (count < min) \n      min = count; \n  } \n  return min; \n} \n"
    },
    {
        "method_name": "matrixchainmultiplication",
        "method_code": "static int matrixChainMultiplication(int p[], int n) { \n  /* For simplicity of the program, one extra row and one \n  extra column are allocated in m[][].  0th row and 0th \n  column of m[][] are not used */\n  int m[][] = new int[n][n]; \n  int i, j, k, L, q; \n  /* m[i, j] = Minimum number of scalar multiplications needed \n  to compute the matrix A[i]A[i+1]...A[j] = A[i..j] where \n  dimension of A[i] is p[i-1] x p[i] */\n  \n  // cost is zero when multiplying one matrix. \n  for (i = 1; i < n; i++) \n    m[i][i] = 0; \n  \n  // L is chain length. \n  for (L = 2; L < n; L++) { \n    for (i = 1; i < n - L + 1; i++) { \n      j = i + L - 1; \n      if (j == n) \n        continue; \n      m[i][j] = Integer.MAX_VALUE; \n      for (k = i; k <= j - 1; k++) { \n      // q = cost/scalar multiplications \n        q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j]; \n        if (q < m[i][j]) \n          m[i][j] = q; \n      } \n    } \n  } \n  return m[1][n - 1]; \n}\n"
    },
    {
        "method_name": "maxminsort",
        "method_code": "public class MaxMinSort {\n\n\tpublic static void sort(int[] a) {\n\t\tint len = a.length;\n\t\tint j = 0;\n\t\tfor (int i=0; i < len; i++) {\n\t\t\tint temp = a[i];\n\t\t\twhile (temp > 0) {\n\t\t\t\tif (i < len / 2)\n\t\t\t\t\tj = 2 * i + 1;\n\t\t\t\telse\n\t\t\t\t\tj = (len - 1 - i) * 2;\n\t\t\t\tif(i==j) {\n\t\t\t\t\ta[i]=-temp;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tswap(temp, a[j]);\n\t\t\t\ta[j] = -1*a[j];\n\t\t\t\ti=j;\n\t\t\t}\n\t\t}\n\t\tfor (int n : a)\n\t\t\tSystem.out.print(n + \" \");\n\t}\n\t\n\tpublic static void swap(int temp, int a) {\n\t\tint swap = a;\n\t\ttemp = a;\n\t\ta = swap;\n  }\n}"
    },
    {
        "method_name": "mergesort",
        "method_code": "public class MergeSort{\n  public static void mergeSort(int[] array, int low, int high) {\n    if (high <= low) return;\n\n    int mid = (low+high)/2;\n    mergeSort(array, low, mid);\n    mergeSort(array, mid+1, high);\n    merge(array, low, mid, high);\n  }\n\n  public static void merge(int[] array, int low, int mid, int high) {\n    int leftArray[] = new int[mid - low + 1];\n    int rightArray[] = new int[high - mid];\n\n    for (int i = 0; i < leftArray.length; i++)\n        leftArray[i] = array[low + i];\n    for (int i = 0; i < rightArray.length; i++)\n        rightArray[i] = array[mid + i + 1];\n\n    int leftIndex = 0;\n    int rightIndex = 0;\n\n    for (int i = low; i < high + 1; i++) {\n        if (leftIndex < leftArray.length && rightIndex < rightArray.length) {\n            if (leftArray[leftIndex] < rightArray[rightIndex]) {\n               array[i] = leftArray[leftIndex];\n               leftIndex++;\n            } else {\n                array[i] = rightArray[rightIndex];\n                rightIndex++;\n            }\n        } else if (leftIndex < leftArray.length) {\n            array[i] = leftArray[leftIndex];\n            leftIndex++;\n        } else if (rightIndex < rightArray.length) {\n            array[i] = rightArray[rightIndex];\n            rightIndex++;\n        }\n    }\n}\n}\n"
    },
    {
        "method_name": "pancakesort",
        "method_code": "class PancakeSort { \n  \n  /* Reverses arr[0..i] */\n  static void flip(int arr[], int i) \n  { \n      int temp, start = 0; \n      while (start < i) \n      { \n          temp = arr[start]; \n          arr[start] = arr[i]; \n          arr[i] = temp; \n          start++; \n          i--; \n      } \n  } \n\n  // Returns index of the  \n  // maximum element in  \n  // arr[0..n-1]  \n  static int findMax(int arr[], int n) \n  { \n      int mi, i; \n      for (mi = 0, i = 0; i < n; ++i) \n          if (arr[i] > arr[mi]) \n              mi = i; \n      return mi; \n  } \n\n  // The main function that \n  // sorts given array using  \n  // flip operations \n  static int pancakeSort(int arr[], int n) \n  { \n      // Start from the complete \n      // array and one by one \n      // reduce current size by one \n      for (int curr_size = n; curr_size > 1; --curr_size) \n      { \n          // Find index of the \n          // maximum element in \n          // arr[0..curr_size-1] \n          int mi = findMax(arr, curr_size); \n\n          // Move the maximum element \n          // to end of current array \n          // if it's not already at  \n          // the end \n          if (mi != curr_size-1) \n          { \n              // To move at the end, \n              // first move maximum \n              // number to beginning \n              flip(arr, mi); \n\n              // Now move the maximum  \n              // number to end by \n              // reversing current array \n              flip(arr, curr_size-1); \n          } \n      } \n      return 0; \n  }\n} "
    },
    {
        "method_name": "pancakesort",
        "method_code": "public class PancakeSort\n{\n   int[] heap;\n \n   public String toString() {\n      String info = \"\";\n      for (int x: heap)\n         info += x + \" \";\n      return info;\n   }\n \n   public void flip(int n) {\n      for (int i = 0; i < (n+1) / 2; ++i) {\n         int tmp = heap[i];\n         heap[i] = heap[n-i];\n         heap[n-i] = tmp;\n      }      \n     // System.out.println(\"flip(0..\" + n + \"): \" + toString());\n   }\n \n   public int[] minmax(int n) {\n      int xm, xM;\n      xm = xM = heap[0];\n      int posm = 0, posM = 0;\n \n      for (int i = 1; i < n; ++i) {\n         if (heap[i] < xm) {\n            xm = heap[i];\n            posm = i;\n         }\n         else if (heap[i] > xM) {\n            xM = heap[i];\n            posM = i;\n         }\n      }\n      return new int[] {posm, posM};\n   }\n \n   public void sort(int n, int dir) {\n      if (n == 0) return;\n \n      int[] mM = minmax(n);\n      int bestXPos = mM[dir];\n      int altXPos = mM[1-dir];\n      boolean flipped = false;\n \n      if (bestXPos == n-1) {\n         --n;\n      }\n      else if (bestXPos == 0) {\n         flip(n-1);\n         --n;\n      }\n      else if (altXPos == n-1) {\n         dir = 1-dir;\n         --n;\n         flipped = true;\n      }\n      else {\n         flip(bestXPos);      }\n      sort(n, dir);\n \n      if (flipped) {\n         flip(n);\n      }\n   }\n \n   PancakeSort(int[] numbers) {\n      heap = numbers;\n      sort(numbers.length, 1);\n   }\n  } "
    },
    {
        "method_name": "prim",
        "method_code": "public class PRIM {\n    void primMST(int graph[][]) \n    { \n        int parent[] = new int[V]; \n  \n        int key[] = new int[V]; \n  \n        Boolean mstSet[] = new Boolean[V]; \n  \n        for (int i = 0; i < V; i++) { \n            key[i] = Integer.MAX_VALUE; \n            mstSet[i] = false; \n        } \n  \n        key[0] = 0; \n        parent[0] = -1;  \n  \n        for (int count = 0; count < V - 1; count++) { \n            int u = minKey(key, mstSet); \n  \n            mstSet[u] = true; \n  \n            \n            for (int v = 0; v < V; v++) \n  \n               \n                if (graph[u][v] != 0 && mstSet[v] == false && graph[u][v] < key[v]) { \n                    parent[v] = u; \n                    key[v] = graph[u][v]; \n                } \n        } \n  \n        printMST(parent, graph); \n    } \n}"
    },
    {
        "method_name": "prim",
        "method_code": "public class Prim {\n    public static int [] prim (WeightedGraph G, int s) {\n    final int [] dist = new int [G.size()];  \n    final int [] pred = new int [G.size()]; \n    final boolean [] visited = new boolean [G.size()]; \n\n    for (int i=0; i<dist.length; i++) {\n        dist[i] = Integer.MAX_VALUE;\n    }\n    dist[s] = 0;\n\n    for (int i=0; i<dist.length; i++) {\n        final int next = minVertex (dist, visited);\n        visited[next] = true;\n        final int [] n = G.neighbors (next);\n        for (int j=0; j<n.length; j++) {\n            final int v = n[j];\n            final int d = G.getWeight(next,v);\n            if (dist[v] > d) {\n               dist[v] = d;\n               pred[v] = next;\n            }\n        }\n    }\n    return pred;  \n    }\n\n    private static int minVertex (int [] dist, boolean [] v) {\n    int x = Integer.MAX_VALUE;\n    int y = -1;   \n    for (int i=0; i<dist.length; i++) {\n        if (!v[i] && dist[i]<x) {y=i; x=dist[i];}\n    }\n    return y;\n    }\n}"
    },
    {
        "method_name": "quicksort",
        "method_code": "class QuickSort {\n \n    int partition(int arr[], int low, int high){ \n        int pivot = arr[high];  \n        int i = (low-1); \n        for (int j=low; j<high; j++) \n        { \n            if (arr[j] <= pivot) \n            { \n                i++; \n  \n                int temp = arr[i]; \n                arr[i] = arr[j]; \n                arr[j] = temp; \n            } \n        } \n  \n        int temp = arr[i+1]; \n        arr[i+1] = arr[high]; \n        arr[high] = temp; \n  \n        return i+1; \n    } \n  \n    void sort(int arr[], int low, int high){ \n        if (low < high) \n        { \n            int pi = partition(arr, low, high); \n\n            sort(arr, low, pi-1); \n            sort(arr, pi+1, high); \n        } \n    }\n}\n"
    },
    {
        "method_name": "quicksort",
        "method_code": "public class QuickSort {\n\tprivate static void quickSort(int[] vetor, int inicio, int fim) {\n\t\tif (inicio < fim) {\n\t\t\tint posicaoPivo = separar(vetor, inicio, fim);\n\t\t        quickSort(vetor, inicio, posicaoPivo - 1);\n\t\t        quickSort(vetor, posicaoPivo + 1, fim);\n\t\t}\n\t}\n\t  \n\tprivate static int separar(int[] vetor, int inicio, int fim) {\n\t\tint pivo = vetor[inicio];\n\t\tint i = inicio + 1, f = fim;\n\t\twhile (i <= f) {\n\t\t\tif (vetor[i] <= pivo){\n\t\t\t\ti++;\n\t\t\t}\n\t\t        else if (pivo < vetor[f]){\n\t\t        \tf--;\n\t\t\t}\n\t\t        else {\n\t\t        \tint troca = vetor[i];\n\t\t                vetor[i] = vetor[f];\n\t\t                vetor[f] = troca;\n\t\t                i++;\n\t\t                f--;\n\t\t        }\n\t\t}\n\t\tvetor[inicio] = vetor[f];\n\t\tvetor[f] = pivo;\n\t\treturn f;\n\t}\n}\n\n"
    },
    {
        "method_name": "quicksort",
        "method_code": "public static void quickSort(int v[], int esquerda, int direita) {\n\tint esq = esquerda;\n\tint dir = direita;\n\tint pivo = v[(esq + dir) / 2];\n\tint troca;\n\n\twhile (esq <= dir) {\n\t\twhile (v[esq] < pivo) {\n\t\t\tesq = esq + 1;\n\t\t}\n\t\twhile (v[dir] > pivo) {\n\t\t\tdir = dir - 1;\n\t\t}\n\t\tif (esq <= dir) {\n\t\t\ttroca = v[esq];\n\t\t\tv[esq] = v[dir];\n\t\t\tv[dir] = troca;\n\t\t\tesq = esq + 1;\n\t\t\tdir = dir - 1;\n\t\t}\n\t}\n\tif (dir > esquerda){\n\t\tquickSort(v, esquerda, dir);\n\t}\n\tif (esq < direita){\n\t\tquickSort(v, esq, direita);\n\t}\n}\n"
    },
    {
        "method_name": "radixsort",
        "method_code": "class RadixSort { \n  \n  // A utility function to get maximum value in arr[] \n  static int getMax(int arr[], int n) \n  { \n      int mx = arr[0]; \n      for (int i = 1; i < n; i++) \n          if (arr[i] > mx) \n              mx = arr[i]; \n      return mx; \n  } \n\n  // A function to do counting sort of arr[] according to \n  // the digit represented by exp. \n  static void countSort(int arr[], int n, int exp) \n  { \n      int output[] = new int[n]; // output array \n      int i; \n      int count[] = new int[10]; \n      Arrays.fill(count,0); \n\n      // Store count of occurrences in count[] \n      for (i = 0; i < n; i++) \n          count[ (arr[i]/exp)%10 ]++; \n\n      // Change count[i] so that count[i] now contains \n      // actual position of this digit in output[] \n      for (i = 1; i < 10; i++) \n          count[i] += count[i - 1]; \n\n      // Build the output array \n      for (i = n - 1; i >= 0; i--) \n      { \n          output[count[ (arr[i]/exp)%10 ] - 1] = arr[i]; \n          count[ (arr[i]/exp)%10 ]--; \n      } \n\n      // Copy the output array to arr[], so that arr[] now \n      // contains sorted numbers according to curent digit \n      for (i = 0; i < n; i++) \n          arr[i] = output[i]; \n  } \n\n  // The main function to that sorts arr[] of size n using \n  // Radix Sort \n  static void radixsort(int arr[], int n) \n  { \n      // Find the maximum number to know number of digits \n      int m = getMax(arr, n); \n\n      // Do counting sort for every digit. Note that instead \n      // of passing digit number, exp is passed. exp is 10^i \n      // where i is current digit number \n      for (int exp = 1; m/exp > 0; exp *= 10) \n          countSort(arr, n, exp); \n  } \n}\n"
    },
    {
        "method_name": "radixsort",
        "method_code": "public void radixSort(int vector[]){\n  for(int digit = 0; digit < 3; digit ++){\n    int power = (int) Math.pow(10, digit+1);\n    \n    int z[][] = new int[vector.length][10];\n    int n[] = new int[10];\n\n    for(int i = 0; i < vector.length; i ++){\n      int num = vector[i];\n      z[n[(num%power)/(power/10)]][(num%power)/(power/10)] = num;\n      n[(num%power)/(power/10)]++;\n      \n    }\n    int c = 0;\n    for(int i = 0; i < 10; i ++){\n      \n      for(int j = 0; j < vector.length; j ++){\n        if(j < n[i]){\n          vector[c] = z[j][i];\n          c++;\n        }else{break;}\n      }\n    }\n    \n  }\n}\n"
    },
    {
        "method_name": "radixsort",
        "method_code": "public class RadixSort {\n  private static final int MAX_CHARS = 28;\n\n  private static void radixSort(String[] v) {\n  Queue<String> queues[] = createQueues();\n  for (int pos = maxSize(v) - 1; pos >= 0; pos--) {\n    for (int i = 0; i < v.length; i++) {\n      int q = queueNo(v[i], pos);\n      queues[q].add(v[i]);\n    }\n    restore(queues, v);\n  }\n}\n\nprivate static void restore(Queue<String>[] qs, String[] v) {\n  int contv = 0;\n  for (int q = 0; q < qs.length; q++)\n    while (qs[q].size() > 0)\n      v[contv++] = qs[q].remove();\n}\n\nprivate static Queue<String>[] createQueues() {\n  LinkedList<String>[] result = new LinkedList[MAX_CHARS];\n  for (int i = 0; i < MAX_CHARS; i++) {\n    result[i] = new LinkedList<String>();\n  }\n  return result;\n}\n\nprivate static int queueNo(String string, int pos) {\n  if (pos >= string.length()) {\n    return 0;\n  }\n  char ch = string.charAt(pos);\n  if ((ch >= 'A') && (ch <= 'Z')) {\n    return (ch - 'A' + 1);\n  }\n  else if (ch >= 'a' && ch <= 'z') {\n    return ch - 'a' + 1;\n  }\n  else {\n    return 27;\n  }\n}\n\nprivate static int maxSize(String[] v) {\n  int maxValue = v[0].length();\n\n  for (int i = 1; i < v.length; i++) {\n    if (maxValue < v[i].length()) {\n      maxValue = v[i].length();\n    }\n  }\n  return maxValue;\n}\n}\n"
    },
    {
        "method_name": "randomsort",
        "method_code": "public class RANDOMSORT {\n\n\tpublic RandomSort(int[] i) {\n\t\tint counter = 0;\n\t\tSystem.out.println(\"I'll sort \" + i.length + \" elements...\");\n\t\twhile(!isSorted(i)) {\n\t\t\tshuffle(i);\n\t\t\tcounter++;\n\t\t}\n\t\tSystem.out.println(\"Solution found! (shuffled \" + counter + \" times)\");\n\t\tprint(i);\n\t}\n\n\tprivate void print(int[] i) {\n\t\tfor(int x : i) {\n\t\t\tSystem.out.print(x + \", \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\tprivate void shuffle(int[] i) {\n\t\tfor(int x = 0; x < i.length; ++x) {\n\t\t\tint index1 = (int) (Math.random() * i.length),\n\t\t\t\tindex2 = (int) (Math.random() * i.length);\n\t\t\tint a = i[index1];\n\t\t\ti[index1] = i[index2];\n\t\t\ti[index2] = a;\n\t\t}\n\t}\n\n\tprivate boolean isSorted(int[] i) {\n\t\tfor(int x = 0; x < i.length - 1; ++x) {\n\t\t\tif(i[x] > i[x+1]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}"
    },
    {
        "method_name": "randomsort",
        "method_code": "public class RANDOMSORT {\n\n    public int[] sort(int[] vetor) {\n        while (!isSorted(vetor)) {\n            shuffle(vetor);\n        }\n        return vetor;\n    }\n\n    private static boolean isSorted(int[] vetor) {\n        for (int i = 0; i < (vetor.length - 1); ++i) {\n            if (vetor[i] > vetor[i + 1]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    private static void shuffle(int[] vetor) {\n        for (int x = 0; x < vetor.length; ++x) {\n            int index1 = (int) (Math.random() * vetor.length),\n                    index2 = (int) (Math.random() * vetor.length);\n            int a = vetor[index1];\n            vetor[index1] = vetor[index2];\n            vetor[index2] = a;\n        }\n    }\n}"
    },
    {
        "method_name": "rodcutting",
        "method_code": "static int rodCutting(int price[], int n) { \n  if (n <= 0) \n    return 0; \n  int max_val = Integer.MIN_VALUE; \n  \n  // Recursively cut the rod in different pieces and \n  // compare different configurations \n  for (int i = 0; i < n; i++) \n    max_val = Math.max(max_val, price[i] + cutRod(price, n - i - 1)); \n  return max_val; \n} \n"
    },
    {
        "method_name": "rodcutting",
        "method_code": "static int rodCutting(int price[], int n) { \n  int val[] = new int[n + 1]; \n  val[0] = 0; \n\n  // Build the table val[] in bottom up manner and return \n  // the last entry from the table \n  for (int i = 1; i <= n; i++) { \n    int max_val = Integer.MIN_VALUE; \n    for (int j = 0; j < i; j++) \n      max_val = Math.max(max_val, price[j] + val[i - j - 1]); \n      val[i] = max_val; \n  } \n  return val[n]; \n} \n"
    },
    {
        "method_name": "saddlebacksearch",
        "method_code": "static boolean saddlebackSearch(int mat[][], int m, int n, int x) { \n\n  int i = m - 1, j = 0;  \n  while (i >= 0 && j < n) { \n    if (mat[i][j] == x) \n      return true; \n    if (mat[i][j] > x) \n      i--; \n    else \n      j++; \n  } \n          \n  return false; \n} "
    },
    {
        "method_name": "saddlebacksearch",
        "method_code": "public class SaddleBackSearch {  \n  private static void searchElement(int TwoDiArray[][], int row, int col, int ele) {     \n    int i = row - 1, j = 0;\n    int flag = 0;  \n      while (i >= 0 && j < col){ \n        if (TwoDiArray[i][j] == ele) {\n          System.out.println(\"Element found at index: {\"+i+\", \"+j+\"}\");\n          flag = 1;\n          break;\n        }\n        if (TwoDiArray[i][j] > ele) \n          i--;\n        else     \n          j++;\n        } \n    if(flag == 0) {\n      System.out.println(\"Element not found\");\n    }\n  } \n}\n"
    },
    {
        "method_name": "selectionsort",
        "method_code": "public static void selectionSort(int[] array) {\n\tfor (int fixo = 0; fixo < array.length - 1; fixo++) {\n\t\tint menor = fixo;\n   \n    \t\tfor (int i = menor + 1; i < array.length; i++) {\n       \t\t\tif (array[i] < array[menor]) {\n          \t\t\tmenor = i;\n       \t\t\t}\n    \t\t}\n    \t\tif (menor != fixo) {\n      \t\t\tint t = array[fixo];\n      \t\t\tarray[fixo] = array[menor];\n      \t\t\tarray[menor] = t;\n    \t\t}\n\t}\n}\n"
    },
    {
        "method_name": "selectionsort",
        "method_code": "public static void selectionSort(int[] arr){  \n        for (int i = 0; i < arr.length - 1; i++){  \n            int index = i;  \n            for (int j = i + 1; j < arr.length; j++){  \n                if (arr[j] < arr[index]){  \n                    index = j;\n                }  \n            }  \n            int smallerNumber = arr[index];   \n            arr[index] = arr[i];  \n            arr[i] = smallerNumber;  \n        }  \n} \n"
    },
    {
        "method_name": "selectionsort",
        "method_code": "void selectionsort(int arr[]){ \n        int n = arr.length; \n  \n        for (int i = 0; i < n-1; i++) \n        { \n \n            int min_idx = i; \n            for (int j = i+1; j < n; j++) {\n                if (arr[j] < arr[min_idx]) {\n                    min_idx = j; \n\t\t}\n  \t    }\n            int temp = arr[min_idx]; \n            arr[min_idx] = arr[i]; \n            arr[i] = temp; \n        } \n}\n"
    },
    {
        "method_name": "shellsort",
        "method_code": "public static void shellSort(Integer[] nums) {\n  int h = 1;\n  int n = nums.length;\n  \n  while(h < n) {\n          h = h * 3 + 1;\n  }\n  \n  h = h / 3;\n  int c, j;\n  \n  while (h > 0) {\n      for (int i = h; i < n; i++) {\n          c = nums[i];\n          j = i;\n          while (j >= h && nums[j - h] > c) {\n              nums[j] = nums[j - h];\n              j = j - h;\n          }\n          nums[j] = c;\n      }\n      h = h / 2;\n  }\n}"
    },
    {
        "method_name": "shellsort",
        "method_code": "public class ShellSort {\n\n\tpublic static void ordenar(int[] vet){\n\t    int i , j , temp, size = vet.length;\n\t    \n\t    int incremento = 1;\n\t    while(incremento < size) {\n\t        incremento = 3 * incremento + 1;\n\t    }\n\t     \n\t    while (incremento > 1) {\n\t        incremento /= 3;\n\t        \n\t        for(i = incremento; i < size; i++) {\n\t            temp = vet[i];\n\t            j = i - incremento;\n\t            while (j >= 0 && temp < vet[j]) {\n\t                vet[j + incremento] = vet[j];\n\t                j -= incremento;\n\t            }\n\t            vet [j + incremento] = temp;\n\t        }\n\t    }\t    \n\t}\t\n}"
    },
    {
        "method_name": "stack",
        "method_code": "public class stack {\n\n\tpublic processo processoAtual;\n\tpublic pilha proximaPilha;\n\t\n\tpublic stack() {\n\t\tthis.processoAtual = null;\n\t\tthis.proximaPilha = null;\n\t}\n\t\n\tpublic void stack(processo processoNovo) {\n\t\tif(this.processoAtual == null) {\n\t\t\tthis.processoAtual = processoNovo;\n\t\t\tthis.proximaPilha = new pilha();\n\t\t} else {\n\t\t\tthis.proximaPilha.inserirpilha(processoNovo);\n\t\t}\n\t}\n\n\tpublic processo stack() {\n\t\tif(this.proximaPilha.proximaPilha == null) {\n\t\t\tprocesso removido = this.processoAtual;\n\t\t\tthis.processoAtual = null;\n\t\t\tthis.proximaPilha = null;\n\t\t\treturn removido;\n\t\t} else {\n\t\t\treturn this.proximaPilha.removerPilha();\n\t\t}\n\t}\n\t\n\tpublic String stack(String vazia) {\n\t\tif(this.proximaPilha.proximaPilha == null) {\n\t\t\tvazia = \" \" + this.processoAtual.getPrioridade() + \" \"  + this.processoAtual.getTempo() + vazia;\n\t\t} else {\n\t\t\tvazia = this.proximaPilha.checkpilha(vazia)+ \" && \" + this.processoAtual.getPrioridade() + \" \"  + this.processoAtual.getTempo() + \" \" + vazia;\n\t\t}\n\t\treturn vazia;\n\t}\n\t\n\tpublic boolean stack() {\n\t\tif(this.proximaPilha == null) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic int stack(int tempo) {\n\t\treturn this.processoAtual.trabalhado(tempo);\n\t}\n}\n"
    },
    {
        "method_name": "stack",
        "method_code": "class Stack {\n\tprivate int arr[];\n\tprivate int top;\n\tprivate int capacity;\n\n\tStack(int size)\n\t{\n\t\tarr = new int[size];\n\t\tcapacity = size;\n\t\ttop = -1;\n\t}\n\n\tpublic void push(int x)\n\t{\n\t\tif (isFull())\n\t\t{\n\t\t\tSystem.out.println(\"OverFlow\\nProgram Terminated\\n\");\n\t\t\tSystem.exit(1);\n\t\t}\n\n\t\tSystem.out.println(\"Inserting \" + x);\n\t\tarr[++top] = x;\n\t}\n\n\tpublic int pop()\n\t{\n\t\tif (isEmpty())\n\t\t{\n\t\t\tSystem.out.println(\"UnderFlow\\nProgram Terminated\");\n\t\t\tSystem.exit(1);\n\t\t}\n\n\t\tSystem.out.println(\"Removing \" + peek());\n\n\t\treturn arr[top--];\n\t}\n\n\tpublic int peek()\n\t{\n\t\tif (!isEmpty())\n\t\t\treturn arr[top];\n\t\telse\n\t\t\tSystem.exit(1);\n\n\t\treturn -1;\n\t}\n\n\tpublic int size()\n\t{\n\t\treturn top + 1;\n\t}\n\n\tpublic Boolean isEmpty()\n\t{\n\t\treturn top == -1;\t\n\t}\n\n\tpublic Boolean isFull()\n\t{\n\t\treturn top == capacity - 1;\t}\n}"
    },
    {
        "method_name": "subsetsum",
        "method_code": "class SubsetSum { \n  \n  static boolean isSubsetSum(int set[], int n, int sum) \n  { \n      if (sum == 0) \n          return true; \n      if (n == 0 && sum != 0) \n          return false; \n\n      if (set[n - 1] > sum) \n          return isSubsetSum(set, n - 1, sum); \n\n      return isSubsetSum(set, n - 1, sum) || isSubsetSum(set, n - 1, sum - set[n - 1]); \n  }\n}\n"
    },
    {
        "method_name": "subsetsum",
        "method_code": "public class SubsetSum {\n\t\n\tpublic static boolean subSetDP(int[] A, int sum) {\n\t\tboolean[][] solution = new boolean[A.length + 1][sum + 1];\t\t\n\t\tfor(int i=1;i<=sum;i++){\n\t\t\tsolution[0][i]=false;\n\t\t}\n\t\t\t\tfor(int i=0;i<=A.length;i++){\n\t\t\t\t\tsolution[i][0]=true;\n\t\t\t\t}\n\t\tfor(int i=1;i<=A.length;i++){\n\t\t\tfor(int j=1;j<=sum;j++){\t\t\t\t\n\t\t\t\tsolution[i][j] = solution[i-1][j];\n\t\t\t\t\n\t\t\t\tif(solution[i][j]==false && j>=A[i-1])\n\t\t\t\t\tsolution[i][j] = solution[i][j] || solution[i-1][j-A[i-1]];\t\t\t\t\n\t\t\t}\n\t\t}\t\t\n\t\treturn solution[A.length][sum];\n  }\n}\n"
    },
    {
        "method_name": "ternarysearch",
        "method_code": "static int ternarySearch(int l, int r, int key, int ar[]) \n    { \n        if (r >= l) { \n  \n            // Find the mid1 and mid2 \n            int mid1 = l + (r - l) / 3; \n            int mid2 = r - (r - l) / 3; \n  \n            // Check if key is present at any mid \n            if (ar[mid1] == key) { \n                return mid1; \n            } \n            if (ar[mid2] == key) { \n                return mid2; \n            } \n  \n            // Since key is not present at mid, \n            // check in which region it is present \n            // then repeat the Search operation \n            // in that region \n  \n            if (key < ar[mid1]) { \n  \n                // The key lies in between l and mid1 \n                return ternarySearch(l, mid1 - 1, key, ar); \n            } \n            else if (key > ar[mid2]) { \n  \n                // The key lies in between mid2 and r \n                return ternarySearch(mid2 + 1, r, key, ar); \n            } \n            else { \n  \n                // The key lies in between mid1 and mid2 \n                return ternarySearch(mid1 + 1, mid2 - 1, key, ar); \n            } \n        } \n  \n        // Key not found \n        return -1; \n    }"
    },
    {
        "method_name": "ternarysearch",
        "method_code": "public static int ternarySearch(int n, int[] arr, int lowerIndex, int upperIndex) {\n  if(n < arr[lowerIndex] || n > arr[upperIndex]) return -1;\n\n  int median = (upperIndex - lowerIndex) / 3;\n  int med1 = lowerIndex + median;\n  int med2 = upperIndex - median;\n\n  if(arr[med1] == n) return med1;\n  if(arr[med2] == n) return med2;\n\n  if(arr[med1] < n) return ternarySearch(n, arr, med1+1, upperIndex);\n  if(arr[med2] > n) return ternarySearch(n, arr, lowerIndex, med2-1);\n\n  return -1;\n}"
    },
    {
        "method_name": "topologicalsort",
        "method_code": "public class TopologicalSort {\n  void topologicalSortUtil(int v, boolean visited[], Stack stack) { \n    visited[v] = true; \n    Integer i; \n    Iterator<Integer> it = adj[v].iterator(); \n    while (it.hasNext()) { \n      i = it.next(); \n      if (!visited[i]) \n        topologicalSortUtil(i, visited, stack); \n    } \n    \n    stack.push(new Integer(v)); \n  } \n  void topologicalSort() { \n    Stack stack = new Stack(); \n    boolean visited[] = new boolean[V]; \n    for (int i = 0; i < V; i++) \n      visited[i] = false; \n    for (int i = 0; i < V; i++) \n      if (visited[i] == false) \n        topologicalSortUtil(i, visited, stack); \n    while (stack.empty()==false) \n      System.out.print(stack.pop() + \" \"); \n  } \n}"
    },
    {
        "method_name": "topologicalsort",
        "method_code": "public class TopologicalSort\n{ \n\tStack<Node> stack;\n \n\tpublic TopologicalSort() {\n\t\tstack=new Stack<>();\n\t}\n\tstatic class Node\n\t{\n\t\tint data;\n\t\tboolean visited;\n\t\tList<Node> neighbours;\n \n\t\tNode(int data)\n\t\t{\n\t\t\tthis.data=data;\n\t\t\tthis.neighbours=new ArrayList<>();\n \n\t\t}\n\t\tpublic void addneighbours(Node neighbourNode)\n\t\t{\n\t\t\tthis.neighbours.add(neighbourNode);\n\t\t}\n\t\tpublic List<Node> getNeighbours() {\n\t\t\treturn neighbours;\n\t\t}\n\t\tpublic void setNeighbours(List<Node> neighbours) {\n\t\t\tthis.neighbours = neighbours;\n\t\t}\n\t\tpublic String toString()\n\t\t{\n\t\t\treturn \"\"+data;\n\t\t}\n\t}\n \n\tpublic  void toplogicalSort(Node node)\n\t{\n\t\tList<Node> neighbours=node.getNeighbours();\n\t\tfor (int i = 0; i < neighbours.size(); i++) {\n\t\t\tNode n=neighbours.get(i);\n\t\t\tif(n!=null && !n.visited)\n\t\t\t{\n\t\t\t\ttoplogicalSort(n);\n\t\t\t\tn.visited=true;\n\t\t\t}\n\t\t}\n\t\tstack.push(node);\n  }\n}"
    },
    {
        "method_name": "fibonacci",
        "method_code": "public class Fibonacci {\n  \n  static long fibo(int n) {\n      int F = 0;     // atual\n      int ant = 0;   // anterior\n\n      for (int i = 1; i <= n; i++) {\n\n          if (i == 1) {\n              F = 1;\n              ant = 0;\n          } else {\n              F += ant;\n              ant = F - ant;\n          }\n\n      }\n\n      return F;\n  }\n}"
    },
    {
        "method_name": "kadane",
        "method_code": "class KadaneAlgorithm \n{\n    public static void maxSum(int[] arr) \n    {\n        int current = arr[0];\n        int global_sum = arr[0];\n        \n        for(int i = 1; i < arr.length; i++)\n        {\n            current = Math.max(arr[i], arr[i] + current);\n            \n            if(current > global_sum)\n            {\n                global_sum = current;\n            }\n        }\n        \n        System.out.println(global_sum);\n    }\n}"
    },
    {
        "method_name": "mergesort",
        "method_code": "class MergeSort \n{ \n    void merge(int arr[], int l, int m, int r) \n    { \n \n        int n1 = m - l + 1; \n        int n2 = r - m; \n  \n        int L[] = new int [n1]; \n        int R[] = new int [n2]; \n  \n        for (int i=0; i<n1; ++i) \n            L[i] = arr[l + i]; \n        for (int j=0; j<n2; ++j) \n            R[j] = arr[m + 1+ j]; \n  \n        int i = 0, j = 0; \n  \n        int k = l; \n        while (i < n1 && j < n2) \n        { \n            if (L[i] <= R[j]) \n            { \n                arr[k] = L[i]; \n                i++; \n            } \n            else\n            { \n                arr[k] = R[j]; \n                j++; \n            } \n            k++; \n        } \n  \n        while (i < n1) \n        { \n            arr[k] = L[i]; \n            i++; \n            k++; \n        } \n  \n        while (j < n2) \n        { \n            arr[k] = R[j]; \n            j++; \n            k++; \n        } \n    } \n  \n    void sort(int arr[], int l, int r) \n    { \n        if (l < r) \n        { \n            int m = (l+r)/2; \n  \n            sort(arr, l, m); \n            sort(arr , m+1, r); \n  \n            merge(arr, l, m, r); \n        } \n    }\n  }"
    }
]